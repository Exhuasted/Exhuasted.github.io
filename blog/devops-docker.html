<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>什么是docker | 前端知识体系</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="欢迎访问我的前端知识体系">
    
    <link rel="preload" href="/assets/css/0.styles.d84cc460.css" as="style"><link rel="preload" href="/assets/js/app.96412ae5.js" as="script"><link rel="preload" href="/assets/js/2.855fd1bb.js" as="script"><link rel="preload" href="/assets/js/9.82bd4b17.js" as="script"><link rel="prefetch" href="/assets/js/10.98a66fdf.js"><link rel="prefetch" href="/assets/js/11.78432c0e.js"><link rel="prefetch" href="/assets/js/12.b96e5543.js"><link rel="prefetch" href="/assets/js/13.9de816a2.js"><link rel="prefetch" href="/assets/js/14.7324994f.js"><link rel="prefetch" href="/assets/js/15.5da2b019.js"><link rel="prefetch" href="/assets/js/3.63ca647c.js"><link rel="prefetch" href="/assets/js/4.702cb367.js"><link rel="prefetch" href="/assets/js/5.b15b42f0.js"><link rel="prefetch" href="/assets/js/6.4fc80a9f.js"><link rel="prefetch" href="/assets/js/7.f1e0c768.js"><link rel="prefetch" href="/assets/js/8.5efcba1f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d84cc460.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="前端知识体系" class="logo"> <span class="site-name can-hide">前端知识体系</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/exhuasted/My-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/exhuasted/My-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>DevOps</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops-webpack-step_01.html" class="sidebar-link">webpack系列（一）使用总结</a></li><li><a href="/blog/devops-webpack-step_02.html" class="sidebar-link">Webpack系列（二）手写模块打包代码</a></li><li><a href="/blog/devops-webpack-step_03.html" class="sidebar-link">Webpack 系列（三）整体流程分析</a></li><li><a href="/blog/git.html" class="sidebar-link">Git 常用使用方式</a></li><li><a href="/blog/devops-docker.html" aria-current="page" class="active sidebar-link">什么是docker</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/devops-kubernetes.html" class="sidebar-link">Kubernetes 使用总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程基础</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络协议</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/osi-http.html" class="sidebar-link">http 协议总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>运维相关</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="什么是docker"><a href="#什么是docker" class="header-anchor">#</a> 什么是docker</h3> <p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，</p> <p>对进程进行封装隔离，属于 操作系统层面的虚拟化技术。</p> <p>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，</p> <p>从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p> <p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。</p> <p>使得 Docker 技术比虚拟机技术更为轻便、快捷。</p> <p>Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p> <p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p> <h3 id="使用-docker-的原因"><a href="#使用-docker-的原因" class="header-anchor">#</a> 使用 docker 的原因</h3> <p>1、更高效的利用系统资源</p> <p>2、更快速的启动时间</p> <p>3、一致的运行环境</p> <p>4、持续交付和部署</p> <p>5、更轻松的迁移</p> <p>6、更轻松的维护和扩展</p> <h3 id="镜像"><a href="#镜像" class="header-anchor">#</a> 镜像</h3> <p>操作系统分为内核和用户空间，Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p> <p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p> <p>镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p> <p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p> <p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p> <p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p> <p>在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p> <p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p> <h3 id="容器"><a href="#容器" class="header-anchor">#</a> 容器</h3> <p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p> <p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。</p> <p>因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</p> <p>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p> <p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。</p> <p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p> <h3 id="仓库"><a href="#仓库" class="header-anchor">#</a> 仓库</h3> <p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。</p> <h3 id="使用镜像"><a href="#使用镜像" class="header-anchor">#</a> 使用镜像</h3> <h4 id="获取镜像"><a href="#获取镜像" class="header-anchor">#</a> 获取镜像</h4> <p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p> <ul><li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub(docker.io)。</li> <li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li></ul> <h4 id="列出镜像"><a href="#列出镜像" class="header-anchor">#</a> 列出镜像</h4> <p>docker image ls/ docker images 列出已经下载下来的镜像</p> <p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p> <h4 id="删除本地镜像"><a href="#删除本地镜像" class="header-anchor">#</a> 删除本地镜像</h4> <p>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</p> <h4 id="使用-dockerfile-定制镜像"><a href="#使用-dockerfile-定制镜像" class="header-anchor">#</a> 使用 Dockerfile 定制镜像</h4> <p>Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p> <h5 id="from-指定基础镜像"><a href="#from-指定基础镜像" class="header-anchor">#</a> FROM 指定基础镜像</h5> <p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。</p> <p>而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p> <h5 id="run-执行命令"><a href="#run-执行命令" class="header-anchor">#</a> RUN 执行命令</h5> <p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p> <ul><li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li> <li>exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。</li></ul> <h5 id="构建镜像"><a href="#构建镜像" class="header-anchor">#</a> 构建镜像</h5> <p>在 Dockerfile 文件所在目录执行</p> <p>docker build [选项] &lt;上下文路径/URL/-&gt;</p> <p>[选项]：https://docs.docker.com/engine/reference/commandline/build/#options</p> <p>-t 指定镜像的名称</p> <p>docker tag</p> <p>https://docs.docker.com/engine/reference/commandline/tag/</p> <h5 id="镜像构建上下文-context"><a href="#镜像构建上下文-context" class="header-anchor">#</a> 镜像构建上下文（Context）</h5> <p>docker build 命令最后有一个 .。. 表示当前目录 ，这是在指定 上下文路径</p> <p>COPY ./package.json /app/</p> <p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，</p> <p>而是复制 上下文（context） 目录下的 package.json</p> <h3 id="操作容器"><a href="#操作容器" class="header-anchor">#</a> 操作容器</h3> <h4 id="启动"><a href="#启动" class="header-anchor">#</a> 启动</h4> <p>docker run [选项] IMAGE [COMMAND] [ARG...]
[选项]：https://docs.docker.com/engine/reference/commandline/run/#options
`
docker run -d -p 9000:3000 docker_demo</p> <p>`
启动镜像  -d 表示后台执⾏，-p  9000:3000 表示指定本地的 9000 端⼝映射到容器内的 3000 端⼝，docker_demo 为镜像名称</p> <p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p> <ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li> <li>利用镜像创建并启动一个容器</li> <li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li> <li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li> <li>从地址池配置一个 ip 地址给容器</li> <li>执行用户指定的应用程序</li> <li>执行完毕后容器被终止</li></ul> <h4 id="守护态运行"><a href="#守护态运行" class="header-anchor">#</a> 守护态运行</h4> <p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p> <p>容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p> <p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls / docker ps 命令来查看容器信息。</p> <p>要获取容器的输出信息，可以通过 log 命令。</p> <p>docker logs [OPTIONS] CONTAINER_ID
Options:
--details        显示更多的信息
-f, --follow         跟踪实时日志
--since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）
--tail string    从日志末尾显示多少行日志， 默认是all
-t, --timestamps     显示时间戳
--until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）</p> <h4 id="终止"><a href="#终止" class="header-anchor">#</a> 终止</h4> <p>docker container stop 来终止一个运行中的容器</p> <p>终止状态的容器可以用 docker container ls -a 命令看到</p> <p>处于终止状态的容器，可以通过 docker container start / docker start 命令来重新启动。</p> <p>docker container restart / docker restart 命令会将一个运行态的容器终止，然后再重新启动它</p> <p>参考文档：
https://yeasy.gitbook.io/docker_practice/</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">1/27/2021, 2:39:10 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/git.html" class="prev">
        Git 常用使用方式
      </a></span> <span class="next"><a href="/blog/devops-kubernetes.html">
        Kubernetes 使用总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.96412ae5.js" defer></script><script src="/assets/js/2.855fd1bb.js" defer></script><script src="/assets/js/9.82bd4b17.js" defer></script>
  </body>
</html>
