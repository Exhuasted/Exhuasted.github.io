(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{442:function(_,r,v){"use strict";v.r(r);var e=v(28),t=Object(e.a)({},(function(){var _=this,r=_.$createElement,v=_._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"什么是docker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是docker"}},[_._v("#")]),_._v(" 什么是docker")]),_._v(" "),v("p",[_._v("Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，")]),_._v(" "),v("p",[_._v("对进程进行封装隔离，属于 操作系统层面的虚拟化技术。")]),_._v(" "),v("p",[_._v("由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，")]),_._v(" "),v("p",[_._v("从 1.11 开始，则进一步演进为使用 runC 和 containerd。")]),_._v(" "),v("p",[_._v("Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。")]),_._v(" "),v("p",[_._v("使得 Docker 技术比虚拟机技术更为轻便、快捷。")]),_._v(" "),v("p",[_._v("Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；")]),_._v(" "),v("p",[_._v("而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。")]),_._v(" "),v("h3",{attrs:{id:"使用-docker-的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-docker-的原因"}},[_._v("#")]),_._v(" 使用 docker 的原因")]),_._v(" "),v("p",[_._v("1、更高效的利用系统资源")]),_._v(" "),v("p",[_._v("2、更快速的启动时间")]),_._v(" "),v("p",[_._v("3、一致的运行环境")]),_._v(" "),v("p",[_._v("4、持续交付和部署")]),_._v(" "),v("p",[_._v("5、更轻松的迁移")]),_._v(" "),v("p",[_._v("6、更轻松的维护和扩展")]),_._v(" "),v("h3",{attrs:{id:"镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#镜像"}},[_._v("#")]),_._v(" 镜像")]),_._v(" "),v("p",[_._v("操作系统分为内核和用户空间，Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。")]),_._v(" "),v("p",[_._v("镜像不包含任何动态数据，其内容在构建之后也不会被改变。")]),_._v(" "),v("p",[_._v("镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。")]),_._v(" "),v("p",[_._v("镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。")]),_._v(" "),v("p",[_._v("比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。")]),_._v(" "),v("p",[_._v("在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。")]),_._v(" "),v("p",[_._v("在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。")]),_._v(" "),v("p",[_._v("分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。")]),_._v(" "),v("h3",{attrs:{id:"容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[_._v("#")]),_._v(" 容器")]),_._v(" "),v("p",[_._v("镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。")]),_._v(" "),v("p",[_._v("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。")]),_._v(" "),v("p",[_._v("因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。")]),_._v(" "),v("p",[_._v("容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。")]),_._v(" "),v("p",[_._v("每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。")]),_._v(" "),v("p",[_._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")]),_._v(" "),v("h3",{attrs:{id:"仓库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#仓库"}},[_._v("#")]),_._v(" 仓库")]),_._v(" "),v("p",[_._v("一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。")]),_._v(" "),v("h3",{attrs:{id:"使用镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用镜像"}},[_._v("#")]),_._v(" 使用镜像")]),_._v(" "),v("h4",{attrs:{id:"获取镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#获取镜像"}},[_._v("#")]),_._v(" 获取镜像")]),_._v(" "),v("p",[_._v("docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]")]),_._v(" "),v("ul",[v("li",[_._v("Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号]。默认地址是 Docker Hub(docker.io)。")]),_._v(" "),v("li",[_._v("仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。")])]),_._v(" "),v("h4",{attrs:{id:"列出镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列出镜像"}},[_._v("#")]),_._v(" 列出镜像")]),_._v(" "),v("p",[_._v("docker image ls/ docker images 列出已经下载下来的镜像")]),_._v(" "),v("p",[_._v("列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。")]),_._v(" "),v("h4",{attrs:{id:"删除本地镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除本地镜像"}},[_._v("#")]),_._v(" 删除本地镜像")]),_._v(" "),v("p",[_._v("docker image rm [选项] <镜像1> [<镜像2> ...]")]),_._v(" "),v("h4",{attrs:{id:"使用-dockerfile-定制镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-dockerfile-定制镜像"}},[_._v("#")]),_._v(" 使用 Dockerfile 定制镜像")]),_._v(" "),v("p",[_._v("Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。")]),_._v(" "),v("h5",{attrs:{id:"from-指定基础镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#from-指定基础镜像"}},[_._v("#")]),_._v(" FROM 指定基础镜像")]),_._v(" "),v("p",[_._v("所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。")]),_._v(" "),v("p",[_._v("而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。")]),_._v(" "),v("h5",{attrs:{id:"run-执行命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#run-执行命令"}},[_._v("#")]),_._v(" RUN 执行命令")]),_._v(" "),v("p",[_._v("RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：")]),_._v(" "),v("ul",[v("li",[_._v("shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。")]),_._v(" "),v("li",[_._v('exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。')])]),_._v(" "),v("h5",{attrs:{id:"构建镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构建镜像"}},[_._v("#")]),_._v(" 构建镜像")]),_._v(" "),v("p",[_._v("在 Dockerfile 文件所在目录执行")]),_._v(" "),v("p",[_._v("docker build [选项] <上下文路径/URL/->")]),_._v(" "),v("p",[_._v("[选项]：https://docs.docker.com/engine/reference/commandline/build/#options")]),_._v(" "),v("p",[_._v("-t 指定镜像的名称")]),_._v(" "),v("p",[_._v("docker tag")]),_._v(" "),v("p",[_._v("https://docs.docker.com/engine/reference/commandline/tag/")]),_._v(" "),v("h5",{attrs:{id:"镜像构建上下文-context"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#镜像构建上下文-context"}},[_._v("#")]),_._v(" 镜像构建上下文（Context）")]),_._v(" "),v("p",[_._v("docker build 命令最后有一个 .。. 表示当前目录 ，这是在指定 上下文路径")]),_._v(" "),v("p",[_._v("COPY ./package.json /app/")]),_._v(" "),v("p",[_._v("这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，")]),_._v(" "),v("p",[_._v("而是复制 上下文（context） 目录下的 package.json")]),_._v(" "),v("h3",{attrs:{id:"操作容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作容器"}},[_._v("#")]),_._v(" 操作容器")]),_._v(" "),v("h4",{attrs:{id:"启动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#启动"}},[_._v("#")]),_._v(" 启动")]),_._v(" "),v("p",[_._v("docker run [选项] IMAGE [COMMAND] [ARG...]\n[选项]：https://docs.docker.com/engine/reference/commandline/run/#options\n`\ndocker run -d -p 9000:3000 docker_demo")]),_._v(" "),v("p",[_._v("`\n启动镜像  -d 表示后台执⾏，-p  9000:3000 表示指定本地的 9000 端⼝映射到容器内的 3000 端⼝，docker_demo 为镜像名称")]),_._v(" "),v("p",[_._v("当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：")]),_._v(" "),v("ul",[v("li",[_._v("检查本地是否存在指定的镜像，不存在就从公有仓库下载")]),_._v(" "),v("li",[_._v("利用镜像创建并启动一个容器")]),_._v(" "),v("li",[_._v("分配一个文件系统，并在只读的镜像层外面挂载一层可读写层")]),_._v(" "),v("li",[_._v("从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去")]),_._v(" "),v("li",[_._v("从地址池配置一个 ip 地址给容器")]),_._v(" "),v("li",[_._v("执行用户指定的应用程序")]),_._v(" "),v("li",[_._v("执行完毕后容器被终止")])]),_._v(" "),v("h4",{attrs:{id:"守护态运行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#守护态运行"}},[_._v("#")]),_._v(" 守护态运行")]),_._v(" "),v("p",[_._v("更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。")]),_._v(" "),v("p",[_._v("容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。")]),_._v(" "),v("p",[_._v("使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls / docker ps 命令来查看容器信息。")]),_._v(" "),v("p",[_._v("要获取容器的输出信息，可以通过 log 命令。")]),_._v(" "),v("p",[_._v("docker logs [OPTIONS] CONTAINER_ID\nOptions:\n--details        显示更多的信息\n-f, --follow         跟踪实时日志\n--since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\n--tail string    从日志末尾显示多少行日志， 默认是all\n-t, --timestamps     显示时间戳\n--until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）")]),_._v(" "),v("h4",{attrs:{id:"终止"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#终止"}},[_._v("#")]),_._v(" 终止")]),_._v(" "),v("p",[_._v("docker container stop 来终止一个运行中的容器")]),_._v(" "),v("p",[_._v("终止状态的容器可以用 docker container ls -a 命令看到")]),_._v(" "),v("p",[_._v("处于终止状态的容器，可以通过 docker container start / docker start 命令来重新启动。")]),_._v(" "),v("p",[_._v("docker container restart / docker restart 命令会将一个运行态的容器终止，然后再重新启动它")]),_._v(" "),v("p",[_._v("参考文档：\nhttps://yeasy.gitbook.io/docker_practice/")])])}),[],!1,null,null,null);r.default=t.exports}}]);